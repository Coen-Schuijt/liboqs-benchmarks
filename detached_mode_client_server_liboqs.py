#!/usr/bin/env python3

import time
import os

def initialyse():
	"""
	Function that stops any running docker containers, rebuilds the image from the docker file, creates a local volume and runs the benchmark-container in detached mode. Sets sysctl settings in order to run the benchmarks.
	"""

	# Start docker deamon.
	print("[ Starting docker deamon ]")
	os.system("/bin/systemctl start docker.service")

	# Stop running container.
	print("\n[ Stopping running container ]")
	os.system("docker stop benchmark-container")

	# Build the benchmark-container from the Dockerfile.
	print("\n[ Building docker container ]")
	os.system("docker build . -t benchmark-container")

	# Create a volume to store results locally.
	print("\n[ Creating docker volume ]")
	os.system("docker volume create benchmark-results-liboqs")
	os.system("docker volume inspect --format '{{ .Mountpoint }}' benchmark-results-liboqs > ./.docker_volume_liboqs.loc")

	# Start the docker container (detached).
	print("\n[ Running docker container ]")
	os.system("docker run --rm -i -t -d --name benchmark-container -v benchmark-results-liboqs:/usr/local/liboqs-benchmarks/results benchmark-container /bin/bash")

	# The following configurations are used in order to run the s_time benchmarks.
	print("\n[ Changing system settings ]")
	os.system("sysctl net.ipv4.tcp_tw_recycle='1'")
	os.system("sysctl net.ipv4.tcp_tw_reuse='1'")

	# Create directory and copy the openssl.cnf file. This makes sure the "openssl.cnf does not exist" warning is supressed.
#	os.system("docker exec -i -t benchmark-container bash -c 'mkdir -p /usr/local/ssl/ ; cp /etc/ssl/openssl.cnf /usr/local/ssl/openssl.cnf'")
	
	return

def generate_ssc():
	"""
	This function creates a self signed certificate and creates a pem file which is used for the s_server function.
	"""

	# Define list of signature algorithms
	sig_algs = ["rsa", "picnicl1fs", "qteslaI", "qteslaIIIsize", "qteslaIIIspeed"]

	# Generate certificate for each of the signature algorithms
	for sig_alg in sig_algs:

		# Create Self Signed Certificate and key
		print("\n[ Creating Self Signed Certificate ({}) ]".format(sig_alg))
		os.system("docker exec -i -t benchmark-container bash -c 'openssl/apps/openssl req -x509 -new -newkey {0} -keyout {0}.key -out {0}.crt -nodes -subj \"/C=NL/ST=Amsterdam/L=Amsterdam/O=OS3/OU=RESEARCH/CN=os3.nl\" -days 365 -config openssl/apps/openssl.cnf'".format(sig_alg))

	return

def run_server():
	"""
	This function opens a SSL/TLS server on port 4444 with provided ciphers.
	"""
	
	sig_algs = ["rsa", "picnicl1fs", "qteslaI", "qteslaIIIsize", "qteslaIIIspeed"]

	for e, sig_alg in enumerate(sig_algs):
		# Setup SSL/TLS server for RSA.
		print("\n[ Setting up SSL/TLS Server ({}) ... Listening on port 444{} ]".format(sig_alg,e))

		os.system("docker exec -i -t -d benchmark-container bash -c 'openssl/apps/openssl s_server -cert {0}.crt -key {0}.key -HTTP -tls1_3 -accept 444{1}'".format(sig_alg,e))

	return

#	os.system("docker exec -i -t -d benchmark-container bash -c 'openssl/apps/openssl s_server -accept 4444 -cipher OQSKEM-DEFAULT:OQSKEM-DEFAULT-ECDHE -cert server-rsa-cert.pem'")

	# Setup SSL/TLS server for ECDSA.
#	print("\n[ Setting up SSL/TLS Server (ECDSA) ... Listening on port 5555 ]")
#	os.system("docker exec -i -t -d benchmark-container bash -c 'openssl/apps/openssl s_server -accept 5555 -cipher OQSKEM-DEFAULT:OQSKEM-DEFAULT-ECDHE -cert ecdsa.cert -key ecdsa.key'")

	return

def generate_file_loc(file_name):
	"""
	This functions reads the file path for the docker-volume and then returns the file path + file name.
	"""

	# File handler. This generates the full file path and file name.
	with open('./.docker_volume_liboqs.loc') as vol_loc:
		data = vol_loc.read()
		data_clean = data.rstrip('\n')
		file_loc = data_clean + "/" + file_name
	
	return file_loc

def run_client():
	"""
	This function runs each of the ciphers as part of the array generated by the generate_ciphers() function, against the server. Sleeps 30 seconds after every cipher.
	"""

	# Initialise lists to start testing
	sig_algs = ["rsa", "picnicl1fs", "qteslaI", "qteslaIIIsize", "qteslaIIIspeed"]
	cipherlist = ["sike503", "sike751", "sidh503", "sidh751", "frodo640aes", "frodo640cshake", "frodo976aes", "frodo976cshake", "bike1l1", "bike1l3", "bike1l5", "bike2l1", "bike2l3", "bike2l5", "bike3l1", "bike3l3", "bike3l5", "newhope512cca", "newhope1024cca"]

	# Run the actual benchmarks
	print("\n[> Running tests for liboqs non_ecdsa_ciphers <]")

	# Default = 30
	duration = 30

	# For each signature algorithm ...
	for e, sig_alg in enumerate(sig_algs):
		
		# ... run al ciphers:
		for cipher in cipherlist:
			command = "docker exec -i -t -d benchmark-container bash -c 'openssl/apps/openssl s_time -connect localhost:444{0} -cipher {1} -cert {2}.crt -key {2}.key -time {3} > ./results/s-time_{2}_{1}_`ls ./results/s-time_{2}_{1}_* | wc -l`.txt 2>&1'".format(e,cipher,sig_alg,duration)
	
			print("\n[ Running benchmarks for [{}] for 60 seconds ]".format(cipher))
#			print(command)
			os.system(command)
	
			print("[ Sleeping for 70 seconds ]") 
			time.sleep(70)
		
	return

if __name__ == "__main__":
	"""
	Main function initialyses the Docker environment, generates a self signed certificate, then starts a SSL/TLS server and finally runs benchmarks for al of these algorithms.
	"""	

	# Run functions	
	initialyse()
	generate_ssc()
	run_server()
	run_client()

#	os.system("sudo parse_client_server.py")
